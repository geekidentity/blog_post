---
categories: Gensim

tags: 
  - Gensim
  - NLP
  - 翻译

title: Gensim官方介绍翻译

date: 2017-12-14
---
# Gensim官方介绍翻译

Gensim是一个[免费](http://radimrehurek.com/gensim/intro.html#availability)的Python库，它可以用来从文档中自动提取语义主题，并且尽可能地做到轻松（对人）高效（对电脑）。

Gensim致力于处理原始的、非结构化的数字文本（纯文本）。Gensim中用到的算法，如**潜在语义分析**（Latent Semantic Analysis，LSA）、**隐含狄利克雷分配**（Latent Dirichlet Allocation，LDA）或**随机预测**（Random Projections）等，是通过检查单词在训练语料库的同一文档中的统计共现模式来发现文档的语义结构。这些算法都是无监督算法，也就是无需人工输入——你仅需一个纯文本的语料库即可。

一旦这些统计模式被发现了，任何纯文本文档都可以在新的语义表示中简洁地表达出来，并用其查询某一文本与其他文本的主题相似性。

> 如果上面的这段话让你感到困惑，请在维基百科阅读更多关于[向量空间模型（](http://en.wikipedia.org/wiki/Vector_space_model)[Vector Space Model](http://en.wikipedia.org/wiki/Vector_space_model)[）](http://en.wikipedia.org/wiki/Vector_space_model)和[非监督文本处理（](http://en.wikipedia.org/wiki/Latent_semantic_indexing)[unsupervised document analysis](http://en.wikipedia.org/wiki/Latent_semantic_indexing)[）](http://en.wikipedia.org/wiki/Latent_semantic_indexing)的内容。

# 特性

- **内存占用低**——任何时候都不会将整个语料库全部读入内存中，可以处理大规模、网络规模的语料库。
- 高效地实现了几种常见的向量空间算法，包括**Tf-idf**、分布式增量**潜在语义分析**、分布式增量**隐含狄利克雷分配**或**随机预测**；增加新的模型也十分方便（真的，不骗你！）。
- 预置了**几种流行的数据格式**的I/O封装器和转换器。
- 文档在语义表示中的**相似性查询**。

创立Gensim的主要动力是（作者）认识到缺乏一个可用的、可扩展的软件框架来实现主题建模，现有的软件都有难以承受的内部复杂性（Java万岁--作者吐槽都是因为Java导致的）。你可以通过阅读我们的[**LREC 2010 workshop paper**](http://radimrehurek.com/gensim/lrec2010_final.pdf)来了解更多的动机，如果你想在自己的工作中引用gensim请引用这篇文章（[**BibTeX**](http://radimrehurek.com/gensim/bibtex_gensim.bib)）。

欢迎通过[**mailing list**](https://groups.google.com/group/gensim)分享你的结果与实验。

Gensim的**主要设计理念**是：

1.      对于开发者而言，提供简单的接口，降低API学习曲线。好的原型（Good forprototyping）。
2.      考虑到输入语料库的大小，尽量降低内存占用；所有中间步骤和算法操作以流的方式，一次访问一个文档。

> 如果您对文档索引/相似性检索感兴趣，我还会维护一个更高级别的文档相似性服务器包。 它在内部使用gensim。

# 核心概念

整个gensim包围绕语料库（Corpus）、向量（Vector）、模型（Model）三个概念展开。

## 语料库

指所有数字文档的集合。该集合被用来自动推断文档的结构、主题等，因此也被称为训练语料库。推断出来的潜在结构可以在接下来为新的没有出现在训练语料库中的文档分配主题，无需人工干预（如手动标记文档或创建其他元数据）。

## 向量

在向量空间模型中（VSM），每个文档都用一组特征(features)代表。例如，每一个特征都可以被认为是一个问答对：

1. 文档中splonge这个单词出现了几次？0
2. 文档中有几个段落？2
3. 文档中有几种字体？5

这些问题通常用它的整数编号（id）来代表（如这里是1,2和3），以便这些文档的表示变成一系列类似(1, 0.0), (2, 2.0), (3, 5.0)的数对。如果我们预先知道所有的问题，我们可以将编号（id）隐含起来，这样可以简单地表示为(0.0, 2.0, 5.0)。这些答案的序列可以被看做是高维空间的向量（本例中是三维）。实际应用中，只有答案是单个实数（或者可以转化为单个实数）的问题才被允许。
每个文档的问题是相同的，当对比两个向量（代表两个文档）时，我们希望可以得到类似“这两个向量的数字非常相似，因此源文档也一定相似”这样的结论。当然，这样的结论是否符合现实取决于我们如何选择我们的问题。

## 稀疏向量

通常情况下，大多数问题的答案是0.0。为了节约空间，我们将这些问题省略，只记录(2, 2.0), (3, 5.0) (请注意(1, 0.0)被省略了)。由于问题集合已经提前知道了，在稀疏表示中所有缺失的属性都可以明确地解析为0.0。
Gensim没有规定任何特殊的语料库格式，一个语料库可以是任何能够连续产生这些稀疏向量的迭代器。例如，set([(2, 2.0), (3, 5.0)], ([0, -1.0], [3, -1.0]))就是一个很平常的有两个文档的语料库，每个文档有两个非0特征-答案（ feature-answer）对。

## 模型

我们使用模型作为抽象术语，指的是从一个文档表示到另一个文档表示的转换。在gensim中，文档被表示为向量，所以模型可以被认为是两个向量空间之间的转换。这个转换的细节是从训练语料库中学到的。

例如，考虑一个模型转换，它采用单词出现的原始计数并对它们进行加权，从而降低常见单词权重并且提升罕见单词权重。任何特定单词权重的准确数值由训练语料库中该单词的相对频率决定。当我们应用这个模型时，我们从一个向量空间（包含原始字数）转换到另一个向量空间（包含加权计数）。


参考：

[1][Gensim官方介绍翻译](http://blog.csdn.net/questionfish/article/details/46715795)



