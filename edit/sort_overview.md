---
categories: algorithm

tags: 
  - 算法

title: 排序算法总结与Java实现

---

# 排序问题的基本概念

### 排序定义

排序是将序列中的记录按照排序码顺序排列起来，而排序码域的值具有不减（或不增）的顺序（这种说法比较严格）。

- 序列（Sequence）：线性表，由记录组成。
- 记录（Record）：结点，进行排序的基本单位。
- 关键码（Key）：能唯一标示记录的一个或多个域。
- 排序码（Sort Key）：作为排序运算依据的一个或多个域（有重复域时使用排序码，即关键码重复）。


### 内排序和外排序。

- 内排序：指在排序期间数据对象全部存放在内存的排序。
    - 直接插入排序
    - Shell 排序
- 外排序：指在排序期间全部对象太多，不能同时存放在内存中，必须根据排序过程的要求，不断在内，外存间移动的排序。

### 正序 VS 逆序 序列

- 正序：待排序序列正好符合排序要求。
- 逆序：把待排序序列逆转过来，正好符合排序要求。

### 排序的稳定性

指如果序列中存在具有多个相同排序码的记录，则在排序后这些记录的相对次序保持不变。

### 排序算法衡量标准主要有

- 时间代价：记录的比较和移动次数。
- 空间代价。
- 算法本身的繁杂程序。

# 插入排序

## 直接插入排序

我们可以用打扑克牌进行说明。在分牌时要整理自己的牌，当拿到一个新牌时，找到一个合适的位置插入。这个原理和插入排序是一样的。举个例子，对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一个数的位置是正确的，则在拿到第一张牌的时候，没必要整理。然后3要插到5前面，把5后移一位，变成3,5,8,6,4.想一下整理牌的时候应该也是这样吧。然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经有序。

### 图示

![image](http://blog.geekidentity.com/images/sorts/insert_sort.gif)

### 代码

``` Java
public class InsertSort {
	/**
	 * 直接插入排序算法对数组进行升序排序
	 * @param array 待排数组
	 */
	public static void sort1(Integer[] array) {
		int temp;
		for (int i = 1; i < array.length; i++) { //依次插入第i 个记录
			temp = array[i];
			//从i 开始向前寻找记录i 的正确位置
			int j = i - 1;
			while (j >= 0 && temp < array[j]) {
				//将那些 >= 记录i 的记录后移
				array[j+1] = array[j];
				j--;
			}
			//最后j 后面就是i 的正确位置，回填
			array[j+1] = temp;
		}
	}
}

```

### 算法分析

该算法是稳定的。

时间代价：

-  |最好 | 最坏
---|---|---
比较次数 | n - 1 | n(n-1)/2 = O(n^2)
移动次数 | 2(n-1) 可优化为0 | (n-1)(n+1)/2 = O(n^2)

平均：O(n^2)

### 算法性质

1. 在最好情况下时间代价为O(n)。
2. 对于短序列，直接插入排序比较有效。

## Shell 排序

Shell 排序有效利用了直接插入排序的两个性质。
其算法主要思想为：
1. 先将序列转化为若干小序列，在这些小序列内进行插入排序。
2. 逐渐增加小序列的规模，而减少小序列个数，使得待排序序列逐渐处于有序状态。
3. 最后对整个序列进行扫尾直接插入排序，从而完成排序。

# 冒泡排序

冒泡排序是最简单的排序之一，大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此而得名。举个例子，对5,3,8,6,4这个无序序列进行冒泡排序。首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。同理4和8交换，变成5,3,4,8,6,3和4无需交换。5和3交换，变成3,5,4,8,6,3.这样一次冒泡就完了，把最小的数3排到最前面了。对剩下的序列依次冒泡就会得到一个有序序列。冒泡排序的时间复杂度为O(n^2)。

## 代码

``` Java
public class BubbleSort {
	public static void sort(Integer[] array) {
		for (int i = 0; i < array.length - 1; i++) {
			boolean isSwap = false;//是否发生了交换的标志，对已经排序差不多的情况可以减少循环次数。
			for (int j = array.length - 1; j > i; j--) {
				if (array[j] < array[j - 1]) {
					int temp = array[j];
					array[j] = array[j-1];
					array[j-1] = temp;
					isSwap = true;
				}
			}
			if (!isSwap) {
				return ;
			}
		}
	}
}
```



## 算法性能

冒泡排序的时间复杂度为O(n^2)。

# 选择排序

选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。举个栗子，对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4.对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。选择排序的时间复杂度为O(n^2)

## 代码

```
public class SelectionSort {
	public static void sort(Integer[] list) {
		for (int i = 0; i < list.length - 1; i++) {
			int min = i;
			for (int j = i+1; j < list.length; j++) {
				if (list[j] < list[min]) {
					min = j;
				}
			}
			if (min != i) {
				int temp = list[i];
				list[i] = list[min];
				list[min] = temp;
			}
		}
	}
}
```



# 快速排序

快速排序一听名字就觉得很高端，在实际应用当中快速排序确实也是表现最好的排序算法。快速排序虽然高端，但其实其思想是来自冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面。

举个栗子：对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，交换之。

5,3,8,6,4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。

5,3,8,6,4 首先设置i,j两个指针分别指向两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。

5,3,4,6,8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。

4,3,5,6,8 一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。

上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。

快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)。

# 堆排序

# 希尔排序
# 归并排序
# 计数排序
# 桶排序
# 基数排序