---
categories: zookeeper 

tags: 
  - ZooKeeper

title: ZooKeeper 总览

date: 2017-02-21
---

# 简单介绍
ZooKeeper是一个集中式服务，用于维护配置信息，命名，提供分布式同步和提供组服务。 Apache ZooKeeper致力于开发和维护一个开放源代码的服务器，实现高度可靠的分布式协调。但没有直接采用Paxos算法，而是采用了被称为ZAB的一致性协议。ZooKeeper 的特征如下：

## 数据模型和分层命名空间

ZooKeeper提供的名称空间非常类似于标准文件系统。 名称是由斜杠 (/) 分隔的一系列路径元素。 ZooKeeper名称空间中的每个节点都由一个路径标识。

![image](http://zookeeper.apache.org/doc/r3.4.9/images/zknamespace.jpg)

与标准文件系统不同，ZooKeeper命名空间中的每个节点都可以具有与其关联的数据以及子节点。它就像有一个文件系统允许文件也是一个目录。 （ZooKeeper被设计为存储协调数据：状态信息，配置，位置信息等，因此存储在每个节点的数据通常很小，在字节到千字节的范围内）。znode表示ZooKeeper Node。

Znodes维护统计结构，包括数据更改，ACL更改和时间戳的版本号，以允许缓存验证和协调更新。每次znode的数据更改时，版本号增加。例如，每当客户端检索数据时，它也接收数据的版本。

存储在命名空间中每个znode的数据以原子方式读取和写入。读取获得与znode相关联的所有数据字节，写入替换所有数据。每个节点都有一个访问控制列表（ACL），限制谁可以做什么。

ZooKeeper也有临时节点的概念。只要创建znode的会话处于活动状态，这些znode就存在。当会话结束时，znode被删除。

## 构建集群

一个ZooKeeper集群通常由一组机器组成，一般3-5台机器就可以组成一个可用的集群，其结构和工作原理如下图所示：

![image](http://zookeeper.apache.org/doc/r3.4.9/images/zkservice.jpg)

只要集群中有超过一半的机器（所以很多人说ZooKeeper 节点个数必须是奇数个）能够正常工作，集群就能够正常对外服务。 ZooKeeper具有以下三种角色：

- Leader： 为客户端提供读写服务 
- Follower：为客户端提供读服务，参与Leader选举过程 
- Observer：为客户端提供读服务，不参与Leader选举过程

## 顺序访问

对于客户端的每个更新请求，ZooKeeper都会分配一个全局唯一的递增编号，反映了所有事务操作的先后顺序，通过这个特点来实现更高层次的同步原语。

## 高性能

# 应用场景

## 服务注册中心

随着分布式的发展和微服务的增多，需要一个管理这些服务的控制中心，即服务注册中心，其主要提供所有服务注册信息的中心存储，同时负责将服务注册信息的更新实时通知给服务消费者，主要通过ZooKeeper的Watcher机制实现。

服务启动，注册临时节点，格式：/{project}rvices/{module}/{ip:port},例如在192.168.1.200服务器上启动某服务模块，服务端口为1234，则其注册节点为：_projectrvices_module/192.168.1.200:1234，并开始初始化服务缓存，把服务模块所有节点信息保存在缓存中，且通过watcher监控路径为/{project}rvices/{module}/下的节点变化，若发生变化，获取节点信息更新缓存，保证缓存和ZooKeeper的信息保持一致，其他模块亦是如此。当需要访问其他模块时，通过算法，得到相应的模块ip:port信息，再通过Http访问其他模块，当然安全认证的过程是不可少的。

## 集群管理

随着分布式系统规模的日益扩大，集群中的机器规模也随之变大，因此，如何更好地进行集群管理也显得越来越重要了。

例如，在日常开发和运维的过程中，平台需要知道当前有多少在线的服务器，以及对机器进行上下线的操作。为了实现自动化的线上运维，我们对机器的上下线情况有一个全局的监控。首先将指定的agent部署到这些机器上并启动，向ZooKeeper指定路径下注册临时节点，完成后，对当前路径watcher的监控就会接受到节点变更事件，即上线通知，同样机器下线时，监控同样会接收到下线通知，这样便实现了对服务器上下线的检测，最后同步数据库，保证数据库准确性以及和真实场景的一致性。

## Leader选举

Leader选举，它是用来保证集群运行的过程中任务执行的唯一性和准确性，如果每个节点服务器都能执行Leader才能执行任务，会导致服务混乱以及数据的不准确性。


分布式都是多实例多点运行，一个服务对应一个多实例服务集群，这些实例运行着相同的程序，对外提供相同的服务。但某些任务只能由Leader执行，当Leader服务器down机或者发生故障时，需要从其他的实例中选举一个Leader来继续执行任务。例如Kafka 中Leader 就是由Zookeeper 选举出来的。

## 分布式锁

分布式锁是控制分布式系统之间同步访问共享资源的一种方式。如果不同的系统或者同一个系统的不同主机之间共享一个或一组资源，那么访问这些资源的时候，会需要通过一些手段来防止彼此之间的干扰，以保证一致性，这个情况下，就需要使用分布式锁了。

产品中分布式锁的实现是通过上述阻塞式，如果是最小节点则获取锁，进行事务处理，不是则大序号临时节点会watcher监听前一个小序号节点存在情况，如果小序号节点消失，大序号节点的实例会受到事件通知，再通过判断，如果是最小，则获取锁，否则继续监听前一个小序号节点，以此类推循环，直到拿到锁为止。