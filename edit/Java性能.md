
# Java应用性能测试的主要内容：

- 应用预期的吞吐量是多少？
- 请求和响应之间的延迟预期是多少？
- 应用支持多少并发用户或并发任务？
- 当并发用户数或并发任务数达到最大时，可接受的吞吐量和延迟是多少？
- 最差情况下的延迟是多少？
- 要使垃圾收集引入的延迟在可容忍范围之内，垃圾收集频率应该是多少？

## CPU 使用率

大多数操作系统的CPU使用率分为用户态CPU使用率和系统态CPU使用率。

- 用户态：是指执行应用程序代码的时间占总CPU时间的百分比。
- 系统态：是指应用执行操作系统调用的时间占总CPU时间的百分比。

系统态CPU使用率高意味着共享资源有竟争或者I/O设备之间有大量的交互。

## CPU调试程序运行队列

### 概念

除CPU使用率之外，监控CPU调度程序运行队列对于分辨系统是否满负荷也有重要意义。

运行队列中就是那些已准备好运行、正等待可用CPU的轻量级进程。

虚拟处理器的个数就是系统硬件线程的个数，也是Java API Runtime.availableProcessors()的返回值。

一般性的指导原则：

- 如果在很长一段时间里，运行队列的长度一直都超过虚拟处理器个数的1倍，就需要关注了，只是暂时还不需要立刻采取行动。
- 如果在很长一段时间里，运行队列的长度达到虚拟处理器个数的3~4倍或更高，则需要立刻引起注意或采取行动。
- 系统运行队列长度等于虚拟处理器个数时，用户不会明显感觉到性能下降。

### 监控方法

* Windows：在Performance Monitor的添加计数器对话框中添加计数器System > Processor Queue Length 。即可监控运行队列长度。
* Linux：vmstat 输出的第一列是运行队列长度，值是运行队列中轻量级进行的实际数量。

## 内存使用

JVM GC器在系统页面交换时的性能也很差，这是由于GC器为了回收不达对象所占用的空间，需要访问大量内存。如果Java堆的一部分被转换出去，就必须先转换进内存以便垃圾收集器扫描存活对象，这会增加GC时间。

### 监控方法

* Windows：在Performance Monitor的添加计数器对话框中添加计数器每秒内存页面调度(Memory\Pages/Second)、可用内存字节数(Memory\Avaiable MBytes)，可以判别系统是否正在进行页面交换。当可用内存变少，并且有页面调试时，系统可能 在进行页面交换。也可以用下面命令显示可用内存和页面交换：


```
typeperf.exe -si 5 "Memory\Available Mbytes" "Memory\Pages/sec"
```

第一列是时间戳，第二列是可用内存，第三列是每秒的页面调度。

如果系统使用的内存量保持稳定，也没有启动新应用，却仍然有页面调度，说明系统可能在进行页面交换。

* Linux：可以用free命令查看内存使用。可用vmstat监控页面交换。si表示内存页面换入量，so表示内存页面换出量。
* 

## 监控锁竟争

Java5 及以上版本的HotSpot VM中增加了锁优化机制。线程通过忙循环自旋(Tight Loop Spin)，尝试获取该锁，如果若干次忙循环自旋之后仍然没有成功，则挂起该线程，等待被唤醒再次尝试获取该锁。挂起和唤醒线程会导致操作系统的让步式上下文切换(Voluntary Context Switch)。因此锁竞争严重的应用会表现出大量的让步式上下文切换。让步式上下文切换耗费的时钟周期代价非常高，通常高达80000（估计值）个时钟周期。

一般性原则：对于任何Java应用，如果让步式上下文切换占去它5%或更多可用时钟周期，说明它可能遇到了锁竞争，即便只占到3%~5%也值得进一步调查。

### 监控方法

可使用pidstat命令监控锁竞争，pidstat -w输出结果是中 cswch/s（所有虚拟处理器的让步式上下文切换）是让步式上下文切换。